import fs from 'fs';
import path from 'path';

const TRADER_ADDRESS = "0x63ce342161250d705dc0b16df89036c8e5f9ba9a";
const OUTPUT_DIR = path.join(process.cwd(), "web/content/docs/lobstah-trader/trader-spotlights", TRADER_ADDRESS);
const TRAWL_FILE = path.join(OUTPUT_DIR, "polymarket-trades.ts");
const RESOLVED_FILE = path.join(OUTPUT_DIR, "resolved-trades.ts");

const GAMMA_API = "https://gamma-api.polymarket.com";

async function resolve() {
    console.log("ü¶û LobstahScout: Correcting Metadata Resolution (V5 - Strict Mapping)...");

    try {
        const trawlContent = fs.readFileSync(TRAWL_FILE, 'utf-8');
        const arrayStart = trawlContent.indexOf('[');
        const arrayEnd = trawlContent.lastIndexOf(']') + 1;
        const trawlTrades = JSON.parse(trawlContent.substring(arrayStart, arrayEnd));

        console.log(`üìä Loaded ${trawlTrades.length} trades.`);

        const assetIds = Array.from(new Set(trawlTrades.map((t: any) => t.asset))).filter(a => a && a !== "0");
        console.log(`üîç Found ${assetIds.length} unique asset IDs. Resolving...`);

        const metadataMap = new Map();
        
        for (const assetId of assetIds) {
            console.log(`üì° Resolving Token: ${assetId}`);
            try {
                // Use clob_token_ids filter - the most precise mapping
                const res = await fetch(`${GAMMA_API}/markets?clob_token_ids=${assetId}`);
                const markets = await res.json();
                
                if (markets && Array.isArray(markets) && markets.length > 0) {
                    const m = markets[0];
                    
                    // ISSUE FIX: Parse token IDs and outcomes safely to find the exact match
                    const clobTokenIds = JSON.parse(m.clobTokenIds || "[]");
                    const outcomes = JSON.parse(m.outcomes || "[]");
                    
                    // Direct index match
                    const outcomeIndex = clobTokenIds.indexOf(assetId);
                    
                    if (outcomeIndex !== -1) {
                        metadataMap.set(assetId, {
                            title: m.question,
                            outcome: outcomes[outcomeIndex] || "Unknown",
                            icon: m.icon,
                            slug: m.slug,
                            eventId: m.eventId
                        });
                        console.log(`  ‚úÖ [${outcomes[outcomeIndex]}] ${m.question}`);
                    } else {
                        // Fallback check for NegRisk markets or nested tokens
                        metadataMap.set(assetId, { title: m.question, outcome: "Complex", icon: m.icon });
                    }
                }
            } catch (e) {
                console.error(`  ! API Error for ${assetId}`);
            }
            await new Promise(r => setTimeout(r, 80)); 
        }

        const resolvedTrades = trawlTrades.map((t: any) => {
            const meta = metadataMap.get(t.asset);
            return {
                ...t,
                title: meta?.title || "Archived Market",
                outcome: meta?.outcome || "Unknown",
                icon: meta?.icon || "",
                isResolved: !!meta
            };
        });

        const fileContent = `/**
 * AUTO-GENERATED BY LOBSTAH-RESOLVER (V5)
 */
export const resolvedData = {
    address: "${TRADER_ADDRESS}",
    count: ${resolvedTrades.length},
    trades: ${JSON.stringify(resolvedTrades, null, 4)}
};
`;

        fs.writeFileSync(RESOLVED_FILE, fileContent);
        console.log(`‚úÖ Success! High-fidelity history resolved to: ${RESOLVED_FILE}`);

    } catch (error) {
        console.error("‚ùå Resolution failed:", error);
    }
}

resolve();
